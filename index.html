<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Museu Virtual WebXR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            pointer-events: none;
        }

        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: none;
            pointer-events: auto;
        }

        #vrButton:hover {
            background: #1557b0;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
        }

        .hotspot {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.9);
            border: 3px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            transition: transform 0.2s;
            pointer-events: auto;
            z-index: 50;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .hotspot:hover {
            transform: scale(1.2);
            background: rgba(33, 150, 243, 1);
        }

        .info-panel {
            position: absolute;
            background: white;
            padding: 20px;
            padding-top: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            pointer-events: auto;
            z-index: 100;
        }

        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .info-panel p {
            margin: 0;
            color: #333;
            line-height: 1.5;
        }

        .info-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
        }

        .info-panel .close-btn:hover {
            background: #d32f2f;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3>üèõÔ∏è Museu Virtual WebXR</h3>
        <p>Carregando ambiente...</p>
        <p style="font-size: 11px; margin-top: 10px;">Use WASD para mover, mouse para olhar</p>
    </div>
    <button id="vrButton">Entrar em RV</button>
    <div id="controls">
        <strong>Controles:</strong><br>
        WASD / Setas: Mover<br>
        Mouse: Olhar ao redor<br>
        Shift: Correr<br>
        Clique nos √≠cones 'i' para informa√ß√µes
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"
        integrity="sha512-n8IpKWzDnBOcBhRlHirMZOUvEq2bLRMuJGjuVqbzUJwtTsgwOgK5aS0c1JA647XWYfqvXve8k3PtZdzpipFjgg=="
        crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/controls/OrbitControls.js"
        integrity="sha256-+ncCNttOcMopCUa47Sn26Tg06ZC2SnWoi/XikKAhnSY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-x3@0.0.10/dist/x3-standalone.js"
        integrity="sha256-oKQUM+QPtvuvLmxpqxdxbrJAq21SZ+7hYK8WlGztXNE=" crossorigin="anonymous"></script>
    <script>

        let scene, camera, renderer, floor;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let isRunning = false;
        let interactiveObjects = [];
        let mouseX = 0, mouseY = 0;
        let targetRotationY = 0, targetRotationX = 0;
        let currentRotationY = 0, currentRotationX = 0;
        let cameraHolder;
        let walls = [];
        let obstacles = []; // Pedestais e objetos
        const playerRadius = 0.5; // Raio de colis√£o do jogador
        const gltfLoader = new THREE.GLTFLoader();
        let x3;

        // Configura√ß√£o inicial
        function init() {
            // Cena
            scene = new THREE.Scene();
            const textureLoader = new THREE.CubeTextureLoader();
            const skyboxTexture = textureLoader.load([
                './images/background 2.jpg', // direita
                './images/background 2.jpg', // esquerda
                './images/background 2.jpg', // topo
                './images/background 2.jpg', // ch√£o
                './images/background 2.jpg', // frente
                './images/background 2.jpg'  // tr√°s
            ]);
            scene.background = skyboxTexture;
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            // C√¢mera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Criar um holder para a c√¢mera (para separar movimento de rota√ß√£o)
            cameraHolder = new THREE.Object3D();
            cameraHolder.position.set(0, 1.6, 5);
            cameraHolder.add(camera);
            scene.add(cameraHolder);

            // Renderer com WebXR
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Ilumina√ß√£o
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ch√£o
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Criar ambiente do museu
            createMuseum();

            // Verificar suporte WebXR
            checkXRSupport();

            // Controles de teclado
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Controle de mouse - movimento livre
            document.addEventListener('mousemove', onMouseMove);

            // Redimensionamento
            window.addEventListener('resize', onWindowResize);

            // Info
            document.getElementById('info').innerHTML = `
                <h3>üèõÔ∏è Museu Virtual WebXR</h3>
                <p>Mova o mouse para olhar ao redor!</p>
                <p style="font-size: 11px; margin-top: 10px;">Clique nos √≠cones 'i' azuis para ver informa√ß√µes</p>
            `;

            // Inicializar x3 debugger ap√≥s todos os elementos estarem criados
            try {
                x3 = new THREEx3({
                    THREE,
                    OrbitControls: THREE.OrbitControls,
                    camera,
                    renderer,
                    scene
                });
            } catch (error) {
                console.warn('x3 debugger n√£o dispon√≠vel:', error);
            }


            // Iniciar anima√ß√£o
            renderer.setAnimationLoop(animate);
        }

        function createMuseum() {
            // Paredes
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });

            // Parede traseira
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, 5, 0.2),
                wallMaterial
            );
            backWall.position.set(0, 2.5, -10);
            scene.add(backWall);
            walls.push({
                min: new THREE.Vector3(-10, 0, -10.1),
                max: new THREE.Vector3(10, 5, -9.9)
            });

            // Paredes laterais
            const sideWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 5, 20),
                wallMaterial
            );
            sideWall1.position.set(-10, 2.5, 0);
            scene.add(sideWall1);
            walls.push({
                min: new THREE.Vector3(-10.1, 0, -10),
                max: new THREE.Vector3(-9.9, 5, 10)
            });

            const sideWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 5, 20),
                wallMaterial
            );
            sideWall2.position.set(10, 2.5, 0);
            scene.add(sideWall2);
            walls.push({
                min: new THREE.Vector3(9.9, 0, -10),
                max: new THREE.Vector3(10.1, 5, 10)
            });

            // Pedestais com objetos
            createPedestal(-5, 0, -5, 0xff6b6b, "Esta√ß√£o Espacial Internacional", "Uma representa√ß√£o detalhada da ISS, destacando sua arquitetura √∫nica e m√≥dulos cient√≠ficos.", "./models/ISS Correctglb.glb");
            createPedestal(0, 0, -5, 0x4ecdc4, "Saturn V", "Um dos foguetes mais poderosos j√° constru√≠dos, simbolizando a explora√ß√£o espacial.w", "./models/saturnVCorrect.glb");
            createPedestal(5, 0, -5, 0xffe66d, "Ouro Solar", "Inspirada nos raios do sol, esta escultura captura luz e movimento em harmonia perfeita.", "./models/Voyager.glb");
            createPedestal(-5, 0, 0, 0x95e1d3, "Serenidade Verde", "Representa a natureza e crescimento. Observe os detalhes entrela√ßados.", "./models/jwst_james_webb_space_telescope.glb");
            createPedestal(5, 0, 0, 0xf38181, "Rosa Eterno", "Uma homenagem ao amor e delicadeza. T√©cnica mista com elementos met√°licos.");

            // Quadros nas paredes
            createPainting(-8, 2, -9.8, 0xff6b6b);
            createPainting(-4, 2, -9.8, 0x4ecdc4);
            createPainting(0, 2, -9.8, 0xffe66d);
            createPainting(4, 2, -9.8, 0x95e1d3);
            createPainting(8, 2, -9.8, 0xf38181);
        }

        function createPedestal(x, y, z, color, title, description, modelPath = null) {
            // Base do pedestal
            const pedestalGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7
            });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(x, y + 0.5, z);
            scene.add(pedestal);

            // Adicionar colis√£o cil√≠ndrica para o pedestal
            obstacles.push({
                type: 'cylinder',
                x: x,
                z: z,
                radius: 0.7
            });

            // Se houver um modelo GLB, carregar; sen√£o usar o objeto padr√£o
            if (modelPath) {
                gltfLoader.load(modelPath, (gltf) => {
                    const model = gltf.scene;
                    model.position.set(x, y + 1.5, z);
                    model.scale.set(0.2, 0.2, 0.2); // Ajustar escala conforme necess√°rio
                    model.userData = {
                        rotate: true,
                        interactive: true,
                        title: title,
                        description: description
                    };
                    scene.add(model);
                    interactiveObjects.push(model);
                }, undefined, (error) => {
                    console.error('Erro ao carregar modelo:', modelPath, error);
                    // Fallback: criar objeto padr√£o
                    createDefaultObject(x, y, z, color, title, description);
                });
            } else {
                createDefaultObject(x, y, z, color, title, description);
            }
        }

        function createDefaultObject(x, y, z, color, title, description) {
            const objectGeometry = new THREE.TorusKnotGeometry(0.3, 0.1, 64, 8);
            const objectMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.7
            });
            const object = new THREE.Mesh(objectGeometry, objectMaterial);
            object.position.set(x, y + 1.5, z);
            object.userData = {
                rotate: true,
                interactive: true,
                title: title,
                description: description
            };
            scene.add(object);
            interactiveObjects.push(object);
        }

        function createPainting(x, y, z, color) {
            // Moldura
            const frameGeometry = new THREE.BoxGeometry(1.5, 2, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y, z);
            scene.add(frame);

            // "Pintura"
            const paintingGeometry = new THREE.PlaneGeometry(1.3, 1.8);
            const paintingMaterial = new THREE.MeshStandardMaterial({ color: color });
            const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
            painting.position.set(x, y, z + 0.06);
            scene.add(painting);
        }

        function checkXRSupport() {
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        const vrButton = document.getElementById('vrButton');
                        vrButton.style.display = 'block';
                        vrButton.addEventListener('click', onVRButtonClick);
                    }
                });
            }
        }

        function onVRButtonClick() {
            if (!renderer.xr.isPresenting) {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor']
                }).then(onSessionStarted);
            }
        }

        function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            renderer.xr.setSession(session);
            document.getElementById('vrButton').textContent = 'Sair da RV';
        }

        function onSessionEnded() {
            document.getElementById('vrButton').textContent = 'Entrar em RV';
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }

        function onMouseMove(event) {
            // Normalizar posi√ß√£o do mouse (-1 a 1)
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = (event.clientY / window.innerHeight) * 2 - 1;

            // Calcular rota√ß√£o alvo - 360 graus de rota√ß√£o horizontal
            targetRotationY = -mouseX * Math.PI; // 360 graus de range horizontal (antes era 180)
            targetRotationX = -mouseY * Math.PI * 0.25; // 90 graus de range vertical
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Suavizar rota√ß√£o da c√¢mera
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;

            // Limitar pitch (rota√ß√£o vertical)
            currentRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, currentRotationX));

            // Aplicar rota√ß√£o apenas na c√¢mera, n√£o no holder
            // Usar ordem de rota√ß√£o YXZ para evitar roll (inclina√ß√£o lateral)
            camera.rotation.order = 'YXZ';
            camera.rotation.y = currentRotationY;
            camera.rotation.x = currentRotationX;
            camera.rotation.z = 0; // For√ßar roll zero (sem inclina√ß√£o lateral)

            // Movimento
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const speed = isRunning ? 50.0 : 25.0;

            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

            // Calcular movimento baseado na dire√ß√£o da c√¢mera (yaw apenas, ignorando pitch)
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            // Vetor forward baseado no yaw da c√¢mera (invertido para corrigir dire√ß√£o)
            forward.set(
                Math.sin(currentRotationY),
                0,
                Math.cos(currentRotationY)
            );

            // Vetor right perpendicular ao forward (invertido para corrigir dire√ß√£o)
            right.set(
                -Math.cos(currentRotationY),
                0,
                Math.sin(currentRotationY)
            );

            // Calcular nova posi√ß√£o baseada na dire√ß√£o da c√¢mera
            const moveAmount = new THREE.Vector3();
            moveAmount.addScaledVector(forward, velocity.z * delta);
            moveAmount.addScaledVector(right, velocity.x * delta);

            const newPosX = cameraHolder.position.x + moveAmount.x;
            const newPosZ = cameraHolder.position.z + moveAmount.z;

            // Verificar colis√µes e aplicar movimento
            if (!checkCollision(newPosX, cameraHolder.position.z)) {
                cameraHolder.position.x = newPosX;
            } else {
                velocity.x = 0;
            }

            if (!checkCollision(cameraHolder.position.x, newPosZ)) {
                cameraHolder.position.z = newPosZ;
            } else {
                velocity.z = 0;
            }

            // Animar objetos
            scene.traverse((child) => {
                if (child.userData.rotate) {
                    child.rotation.y += delta * 0.5;
                }
            });

            prevTime = time;

            x3.fps(() => {
                renderer.render(scene, camera);
            })

            // Atualizar posi√ß√£o dos hotspots
            updateHotspots();
        }

        function updateHotspots() {
            interactiveObjects.forEach(obj => {
                // Calcular dist√¢ncia do objeto √† c√¢mera
                const distance = camera.position.distanceTo(obj.position);

                // S√≥ mostrar hotspots para objetos pr√≥ximos (at√© 15 unidades)
                if (distance > 15) {
                    const hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);
                    if (hotspot) hotspot.style.display = 'none';

                    // Remover painel se o objeto estiver longe
                    const panel = document.querySelector(`.info-panel[data-object="${obj.uuid}"]`);
                    if (panel) panel.remove();
                    return;
                }

                const vector = obj.position.clone();
                vector.project(camera);

                // Verificar se est√° na frente da c√¢mera
                if (vector.z > 1) {
                    const hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);
                    if (hotspot) hotspot.style.display = 'none';

                    // Remover painel se o objeto estiver atr√°s
                    const panel = document.querySelector(`.info-panel[data-object="${obj.uuid}"]`);
                    if (panel) panel.remove();
                    return;
                }

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

                let hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);

                if (!hotspot) {
                    hotspot = document.createElement('div');
                    hotspot.className = 'hotspot';
                    hotspot.innerHTML = 'i';
                    hotspot.dataset.object = obj.uuid;
                    hotspot.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Pegar posi√ß√£o real do hotspot no momento do clique
                        const rect = hotspot.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        showInfoPanel(obj, centerX, centerY);
                    });
                    document.body.appendChild(hotspot);
                }

                hotspot.style.left = `${x - 20}px`;
                hotspot.style.top = `${y - 20}px`;
                hotspot.style.display = 'flex';
            });
        }

        function showInfoPanel(object, hotspotX, hotspotY) {
            // Remover pain√©is existentes
            document.querySelectorAll('.info-panel').forEach(p => p.remove());

            const panel = document.createElement('div');
            panel.className = 'info-panel';
            panel.dataset.object = object.uuid;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = function () {
                panel.remove();
            };

            const title = document.createElement('h3');
            title.textContent = object.userData.title;

            const description = document.createElement('p');
            description.textContent = object.userData.description;

            panel.appendChild(closeBtn);
            panel.appendChild(title);
            panel.appendChild(description);

            // Adicionar ao DOM primeiro para calcular dimens√µes
            document.body.appendChild(panel);

            // Agora pegar dimens√µes reais
            const panelWidth = panel.offsetWidth;
            const panelHeight = panel.offsetHeight;
            const padding = 15;

            // Tentar posicionar √† direita do hotspot
            let panelX = hotspotX + padding;
            let panelY = hotspotY - (panelHeight / 2);

            // Se n√£o couber √† direita, colocar √† esquerda
            if (panelX + panelWidth > window.innerWidth - 10) {
                panelX = hotspotX - panelWidth - padding;
            }

            // Se n√£o couber √† esquerda tamb√©m, for√ßar dentro da tela
            if (panelX < 10) {
                panelX = 10;
            }

            // Garantir que n√£o saia verticalmente
            if (panelY < 10) {
                panelY = 10;
            }
            if (panelY + panelHeight > window.innerHeight - 10) {
                panelY = window.innerHeight - panelHeight - 10;
            }

            panel.style.left = `${panelX}px`;
            panel.style.top = `${panelY}px`;
        }

        function checkCollision(x, z) {
            // Verificar colis√£o com paredes
            for (let wall of walls) {
                const expandedMin = {
                    x: wall.min.x - playerRadius,
                    z: wall.min.z - playerRadius
                };
                const expandedMax = {
                    x: wall.max.x + playerRadius,
                    z: wall.max.z + playerRadius
                };

                if (x > expandedMin.x && x < expandedMax.x &&
                    z > expandedMin.z && z < expandedMax.z) {
                    return true;
                }
            }

            // Verificar colis√£o com obst√°culos (pedestais)
            for (let obstacle of obstacles) {
                if (obstacle.type === 'cylinder') {
                    // Calcular dist√¢ncia entre jogador e obst√°culo
                    const dx = x - obstacle.x;
                    const dz = z - obstacle.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    // Verificar se h√° colis√£o (soma dos raios)
                    if (distance < obstacle.radius + playerRadius) {
                        return true;
                    }
                }
            }

            return false;
        }

        init();
    </script>
</body>

</html>